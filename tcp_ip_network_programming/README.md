# 一 理解网络编程和套接字
## 1.1 理解网络编程和套接字
- 网络编程中`接受`连接请求的套接字创建过程：
    - 调用socket函数创建套接字
    - 调用bind函数分配IP地址和端口号
    - 调用listen函数转为可接受请求状态
    - 调用accept函数受理连接请求
    - `如果启动了server，不能够立即重启服务端`
- `客户端`创建套接字的过程：
    - 调用socket函数和connect函数
    - 与服务端共同运行以收发字符串数据
## 1.2 基于Linux的文件操作
>在Linux中不区分`套接字`与`文件`，或则说套接字是一种文件
## 问题
- `套接字编程`与`网络编程`的联系
    - OS提供套接字(socket),套接字是网络传输的软件设备，所以`网络编程`就是`套接字编程`
- `底层文件IO(比如open)`与`ANSI标准的IO(比如fopen的区别)`
    - 文件I/O 又称为低级磁盘I/O，遵循POSIX相关标准。任何兼容POSIX标准的操作系统上都支持文件I/O。标准I/O被称为高级磁盘I/O，遵循ANSI C相关标准。只要开发环境中有标准I/O库，标准I/O就可以使用。（Linux 中使用的是GLIBC，它是标准C库的超集。不仅包含ANSI C中定义的函数，还包括POSIX标准中定义的函数。因此，Linux 下既可以使用标准I/O，也可以使用文件I/O）。
    - 通过文件I/O读写文件时，每次操作都会执行相关系统调用。这样处理的好处是直接读写实际文件，坏处是频繁的系统调用会增加系统开销，标准I/O可以看成是在文件I/O的基础上封装了缓冲机制。先读写缓冲区，必要时再访问实际文件，从而减少了系统调用的次数。
    - 文件I/O中用文件描述符表现一个打开的文件，可以访问不同类型的文件如普通文件、设备文件和管道文件等。而标准I/O中用FILE（流）表示一个打开的文件，通常只用来访问普通文件。
    - `底层IO`是系统调用，`文件IO`是函数，为了可移植性，因为库函数是对系统调用的封装，最好不要直接使用`系统调用`
# 二 套接字类型与协议设置
- TCP套接字和UDP套接字不会共用端口号，也即如果某TCP套接字使用9190端口，那么其他TCP套接字无法使用该端口号，但是UDP套接字可以使用
- 主流intel/AMD CPU是使用`小端序`，而网络传输数据采用`大端序`，大小端转换函数,其中`h`表示`host`，`n`表示`network`，`s`表示`short`(常用于端口转换)，`l`表示`long`（常用于IP地址转换，linx中long占4个字节)，**在本身就是大端的机器上，不会发生变化**：
    - unsigned short htons(unsigned short);
    - unsigned short ntohs(unsigned short);
    - unsigned long htons(unsigned long);
    - unsigned long ntohs(unsigned long);
- 除了向`sockaddr_in`填充数据之外，在传输数据的时候，不需要转换`大小端`。
- `in_addr_t inet_addr(const char * string)`用来将点分十进制转为`uint32_t`,并且会`检查错误`
- `int inet_aton(const char * string, struct in_addr * addr)`,也是将点分十进制转换为`uint32_t`，并且会将数据存储在`addr`中。
- `char *inet_ntoa(struct in_addr adr)`,此函数是将`uint32_t`转换为点分十进制，多次调用，需要将返回的char*的字符串拷贝，不然第二次调用会被覆盖。
- `addr.sin_addr.s_addr = htol(INADDR_ANY)`表示可以监听宿主机上的任意NIC的IP
# 四 基于TCP的服务器端/客户端(1)
- `网络编程的大部分内存就是设计并实现应用层协议`
- listen函数就是创建一个可以接受请求`服务端套接字`，该套接字相当于一个门，listen的第二个参数决定了`连接请求队列的大小`
- 由于`服务端套接字`需要当门卫，那么每次`accept`的时候需要创建`新的套接字`，用来与客户端连接
- 对于TCP的传输数据`没有边界性`，存在一些问题：
    - 多次write函数，可能会被client一次性接受
    - 也存在一次write函数的数据太长，数据需要分成两个数据包发送，那么client有可能在全部数据包未收全时，就是调用read
## 问题
- 什么时候创建连接请求等待队列？它有何种作用？与accept有什么关系？
    - 服务端调用listen函数后，accept函数正在处理客户端请求时，更多的客户端发来了请求连接的数据，此时，就需要创建连接请求等待队列。以便在accept函数处理完手头的请求之后，按照正确的顺序处理后面正在排队的其他请求。与accept函数的关系：accept函数受理连接请求等待队列中待处理的客户端连接请求。
- 客户端中为何不需要调用bind函数分配地址？如果不调用bind函数，那何时，如何向套接字分配IP地址和端口号？
    - 在调用connect函数时分配来地址，客户端IP地址和端口在调用connect函数时自动分配，无需调用标记bind函数进行分配。
# 五 基于TCP的服务器端/客户端(2)
- `应用层协议：`服务器端/客户端实现过程中逐步定义的这些规则集合就是应用层协议。
- `回声服务器的问题：`类似与`粘包/拆包`问题，client发送多少字节的数据，server就应该接受回送多少字节的数据。问题在于，***如果client要发送的包太大，server分成两次接受，那么有可能出现client在未收到全部数据包时，就调用read函数，会出现一个包的数据，分两行打印的情况**
- **习题等会写。。。**
# 六 基于UDP的服务端/客户端
- 在TCP中，若要向10个客户端提供服务，除了需要`守门`的套接字之外，还需要`10个服务器套接字`，但在UDP中，不管是客户端还是服务端，都只需要`一个套接字`。
- 在`TCP套接字`中，调用`connect`时OS会自动分配给套接字IP和端口号，无需调用bind函数分配;而在`UDP`中调用`sendto`函数时自动分配，而且这次分配会持续到程序结束为止。
- TCP数据传输不存在边界，也就是说`数据传输过程中IO函数的调用次数不具备任何意义`;UDP数据传输存在边界，`所以传输数据过程中调用IO函数的次数非常重要，也就是说输入函数调用的次数需要与输出函数的次数完全一致，因为是以数据包的方式传输`
- `UDP套接字`没有注册目标地址，那么可以重复利用同一套UDP套接字向不同目标传输数据，注册了目标地址的`套接字`叫做`connected`套接字，UDP的套机字会在调用一次sendto之后删除注册，那么这样效率很低
- UDP套接字`可以使用`已经分配给TCP的同一端口号。
- **7编程作业之后写**
# 七 优雅的断开套接字连接
- `只关闭一部分数据交换中使用的流`是指`传输数据但无法接受，或者接受数据但无法传输`，也就是关闭流的一半。
- `Linux的close函数`将把一个socket的输入/输出流都断开，那么需要`shutdown(int sock, int howto)函数`，第二个参数的可选值：
    - SHUT_RD 断开输入流
    - SHUT_WR 断开输出流
    - SHUT_RDWR 同时断开IO流
- 服务器在断开输出流的时候向客户端输出`EOF`
# 八 域名以及网络地址
- `nslookup`用来查看默认dns服务器地址，输入该命令之后，会提示输入`server`
- `DNS`可以看作是一个`分布式数据库系统`
- 不使用`IP`的原因，`IP`地址容易发生变化，且难以记忆
- 利用域名获取IP地址的函数`struct hostent *gethostname(const char *hostname);`
# 九 套接字的多种可选项
- 信号`CTRL+C`终止`server`，之后在去使用同一端口启动服务端，会出现`bind() error`,原因在于`time-wait`
- `time-wait`状态，在需要快速重启服务器的情况下，并不收欢迎，可以在套接字的可选项中更改`SO_REUSEADDR`的状态，其默认值为0,将其值设置为1,那么在`time-wait`状态下，就会被分配新的套接字端口
- `Nagle算法`：Nagle会最大限度的缓冲数据，在收到上一次发送的数据的ACK之前，不会去发送新的数据，而是尽量将数据缓存在缓冲区之中，这样可以减轻网络负载。但是传递`大文件数据`的时候，不适合使用`Nagle`算法，因为这个时候不需要等待ACK了，就可以连续发送。可以通过将套接字选项`TCP_NODELAY`修改为1,来禁用Nagle算法
# 十 多进程服务器端
- 实现`并发服务器端的实现模型与方法：`
    - 多进程服务器 
    - 多路复用服务器
    - 多线程服务器
- 对于子进程的`终止`，需要调用exit函数或者return函数，os不会去销毁子进程，直到exit的值或return返回的值被传递给父进程，但是需要父进程主动`发起请求`，os才会传递该值。换言之，如果os未主动要求获得子进程的结束状态值，os将一致保存，并让子进程长时间处于僵尸状态。
    - 利用`wait函数`，pid_t wait(int *statloc),如果调用该函数的时候，已经有子进程结束，那么子进程终止时传递的返回值将保存在该函数的参数所指的内存空间中。调用`wait`函数，如果没有已经终止的子进程，那么程序将阻塞直到有子进程终止。
    - `pid_t waitpid(pid_t pid, int *statloc, int options);`也可以回收僵尸进程，并且可以防止阻塞,第一个参数如果是-1,那么该函数和wait函数一样，可以等待任意子进程终止
    - 对于子进程的回收，父进程不能够只做这一件事，所以需要通过OS发送`信号`给`父进程`
        - 信号与singal函数，`void (*signal(int signo, void (*func)(int)))(int)`,参数是int signo， void（*func）(int),返回类型是参数为int型，返回为void型函数指针(这个返回值就是之前注册的函数指针)。这个函数用来`注册`信号函数
        - 调用函数的主体的确是OS，但是进程处于睡眠状态时无法调用函数，所以产生信号时(alarm到点，CTRL+C等)，`为了调用信号处理器，将唤醒由于调用sleep函数而进入阻塞状态的进程`，而且，进程一旦被唤醒，就不会再进入睡眠状态了，
    - 在父进程调用fork()之后，子进程只会复制文件描述符，对于`套接字`本身，不会发生复制，不然就同一端口对应多个套接字了
# 十一 进程间通信
- 为了实现进程间通信，OS需要为两个进程提供可以`同时访问的内存空间`
    - 通过`管道`实现进程间通信,fds[1]是管道入口，fds[0]是管道出口,`管道和套接字一样，属于OS,不是fork函数的赋值对象，但是fd的文件描述符是可以复制的`。一个进程在管道里写数据，也可以读出自己写的数据。父进程结束的时候，子进程可以仍然`在运行。`
- 使用`管道和进程`并发服务器,服务多客户端并非高效之举.
# 十二 I/O复用
- 多进程的方式来处理多个客户端,代价极大,需要大量的运算和内存空间,并且进程间通信(IPC)比较复杂
- `复用`的概念就像通信领域的`时分复用`/`频分复用`,只需要一个进程
  - `select`,linux和windows下都可以使用,所以具有良好的`移植性`
    - select监听三种`事件`(也就是监视项):接受数据,无需阻塞传输数据,异常
# 十三 多种I/O函数
- `send/recv`与 `write/read`的区别在于前者有第四个参数`flags`
- TCP并不提供真正的`通过单独通信路径高速传输数据的带外数据`,只是利用`紧急模式`进行传输,所以只能够读取1个字节,剩余数据只能通过未设置MSG_OOB可选项的普通输入函数读取,也就是说`紧急消息的意义在于督促消息处理,也就是不需要等待缓冲区满,而SIGURG信号处理函数只处理一个字节`?
- `readv/writev`函数可以将数据进行整合传输及发送,也即writev函数可以将分散保存的在多个缓冲中的数据一并大送,readv函数可以由多个缓冲区分别接受,这两个函数可以减少IO函数的调用次数
# 十四 多播与广播
- `多播`是基于`udp`的,但是其可以同时向多个主机传递数据
- `广播`和`多播`的区别在于,多播可以向不同网络的同一组的主机发送数据,而广播只能够向同一网络的主机发送数据
  - `直接广播`,如果想要向192.12.34的网络发送广播,那么广播地址是`192.12.34.255`
  - `本地广播`,`255.255.255.255`
- `虚拟网络`是指通过网络中的特殊协议工作的软件概念上的网络,也就是说,用于多播方式的数据通信的MBone虚拟网络,,并非可以触及的物理网络,它是以物理网络为基础,通过软件的方式实现的多播通信必备虚拟网络
# 十五 套接字和标准IO
- `标准IO(fopen)`相比较与`系统IO(open)`而言
  - 有缓冲区,使用标准IO时,会经过两个缓冲区,一个是标准IO的缓冲,一个是套接字的缓冲,缓冲区的好处在与
    - 传输数据量大时,可以减少发送头部信息
    - 如果没有`输出缓冲区`,那么直接向`套接字`缓冲区多次移动数据还会消耗不少时间
  - 移植性好
- `标准IO`的缺点在于
    - 不容易进行双向通信
    - 有时可能频繁调用fflush函数，切换读写状态的时候需要刷新缓冲区
    - 需要以FILE结构体指针的形式返回文件描述符
- 在读写套接字的时候，为了使用标准IO函数，需要使用`fdopen(int fildes, const char *mode)`函数将`文件描述符`转换为`FILE结构体指针`，
- 也可以使用`fileno(FILE *stream)函数`将函数指针转换为文件描述符
- `标准IO函数`是以`字符串`为单位进行数据交换的，所以在回声客户端中不需在数据尾部插入0?
# 十六 关于IO流分离的其他内容
- 调用`fopen函数`之后创建了`流`，这里的流指的是数据流动，也就是以数据收发为目的的一种桥梁，也可以理解为数据收发路径
- 两种分离流的方式：
    - 通过fork方法复制出一个文件描述符，以区分输入输出中使用的文件描述符
    - 通过`fdopen`函数创建读模式FILE指针和写模式FILE指针
- 分离`流`的目的
    - 通过分开输入过程和输出过程降低实现难度
    - 与输入无关的输出操作可以提高速度
    - 为了将FILE指针按读模式和写模式加以区分
    - 可以通过区分读写模式降低实现难度
    - 通过区分IO缓冲区提高缓冲性能
- 对写模式FILE指针调用fclose函数，终止套接字时，可以向对方主机发送EOF,并且这个时候就算是分离了FILE读写模式，也会是全关闭，所以需要在创建FILE指针之前`先复制文件描述符`，因为`销毁了所有的文件描述符，才会销毁套接字`，但是这个时候并不是`半关闭状态`。复制文件描符不能使用`fork`，因为fork会复制一整个进程，这里需要在一个进程中复制文件描述符，这里的复制是指两个数字不同的文件描述符指向同一个文件,使用`dup/dup2`
# 十七 优于select的epoll
- select复用方法无论如何也不能同时接入上百个客户端，缺点在于
    - 每次调用select需要针对所有的文件描述符循环
    - 每次调用select函数时都需要重复向该函数传递监视对象信息(也就是说需要每次向内核态传递信息，epoll优化的点在在于它只会传递一次监视对象，但是在监视范围或内容发生变化时通知发送变化的事项)
- select的优点在于：
    - 服务端接入者少
    - 程序具有兼容性
- epoll的优点在于：
    - 无需编写以监视状态变化为目的的针对所有文件描述符的循环语句
    - 调用对应于select函数的epoll_wait函数时，不需要传递监视信息
- `epoll_create`会创建一个名为`epoll例程`的用来保存文件描述符的空间,epoll_create创建的资源与套接字相同,由os管理,该函数返回文件描述符用来区分多个epoll例程.需要终止时,与其他文件描述符相同,需要调用close函数
- `epoll_ctl`优点是在其内部注册监视对象文件描述符,`epoll_event`结构体中保存了发生事件的文件描述符和用于注册关注的事件
- `level trigger(条件触发,默认是)`
    - 只要缓冲区中有数据就会一直通知该事件,比如服务端输入缓冲区收到50字节的数据,服务器os将会通知改事件(注册到发送变化的文件描述符),但服务器读取20字节后还剩30字节的情况下,仍然会`注册事件`,在条件触发方式中,只要输入缓冲区中还剩有数据,就将以事件的方式再次注册
- `edge trigger(边缘触发，需要在event结构体的events字段中填入EPOLLET指定)`
  - 边缘触发只有在触发中,输入缓冲区收到数据时仅注册一次该事件,即使输入缓冲区中的数据没有被读取完,`边缘触发可以分离接受和处理数据的时间点`
- `fcntl函数`可以将套接字设置为非阻塞的，`int flag = fcntl(fd, F_GETFL, 0); fcntl(fd, S_SETFL, flag | O_NONBLOCK);`
- 为什么需要将套机字变成非阻塞模式?在边缘模式下，以阻塞方式工作的read&write有可能引起服务器端的长时间停顿，因此，边缘触发方式下一定要采用非阻塞read&write函数。(既然可以在读取到数据为0的时候，对于上str_len==0的时候作出判断，那么对于str_len<0的时候的判断是什么意思，猜测应该是str_len==0的时候是读取到了eof，而str_len<1的时候，会是非阻塞模式下，输入缓冲区中已经没有数据了，并且没有接收到eof。)
# 十八 多线程服务器端的实现
- 多进程模型的缺点：
    - 创建进程的过程会带来一定的开销
    - 进程间数据交换，需要特殊的IPC技术
    - 每秒少则数十次，多则数千次的`上下文切换`
- `线程`相对于`进程`而言：
    - `进程`是在OS中构成单独的执行流的单位，`线程`是在进程中构成单独执行流的单位
    - 线程的创建和上下文切换比进程的创建与上下文切换更快，上下文切换时，不需要切换`数据区`和`堆`
    - 线程间交换数据无需特殊技术，也就是利用`数据区`与`共享堆区`来交换数据
- POSIX是为了提高UNIX系列操作系统间的移植性而定制的API规范。
- `restrict关键字`：restrict是c99标准引入的，它只可以用于限定和约束指针，并表明指针是访问一个数据对象的唯一且初始的方式.即它告诉编译器，所有修改该指针所指向内存中内容的操作都必须通过该指针来修改,而不能通过其它途径(其它变量或指针)来修改;这样做的好处是,能帮助编译器进行更好的优化代码,生成更有效率的汇编代码.如 int *restrict ptr, ptr 指向的内存单元只能被 ptr 访问到，任何同样指向这个内存单元的其他指针都是未定义的，直白点就是无效指针。restrict 的出现是因为 C 语言本身固有的缺陷，C 程序员应当主动地规避这个缺陷，而编译器也会很配合地优化你的代码.
- `int pthread_join(pthread_t thread, void ** status)函数`，调用该函数的进程/线程将进入等待状态，直到第一个参数位ID的线程终止为止。而且可以通过status获取该线程的main函数的返回值
- `临界区`是指多个线程同时执行这部分代码会出问题，根据临界区是否引起问题，函数可以分为两种：
    - 线程安全函数(Thread-safe function)，线程安全的函数被多个线程同时调用也不会出问题，线程安全的函数并不是一定没有`临界区`，指示采取了一些措施来避免问题，一般在linux中，如果存在线程不安全的函数，也会提供其线程安全的版本，比如`gethostname_r`就是线程安全的`gethostname`的线程安全版本。
    - 线程不安全函数(Thread-unsafe function)
- `工作线程模式`，main线程是master，给其他线程分配任务，并且负责输出结果的工作，
- 声明头文件前，定义`_REENTERANT宏`，可以自动将gethostbyname函数改为gethostbyname_r函数调用
- `pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t * attr);`函数如果第二个参数传递NULL,那么可以使用`pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER`达成同样的效果，但不建议这样做，因为难以debug
- `信号量semaphore`， `int sem_init(sem_t *sem, int pshared, unsigned int value);`第二个参数在使用非0值时，创建的信号量是在多个进程间共享，传递0时，创建的信号量是只允许一个进程内部使用，
- `pthread_join`虽然可以回收线程，但是函数会导致函数阻塞，`pthread_detach`函数可以销毁
- 临界区由访问全局变量的代码构成。其他变量中不会发生问题。???`对还是错`
## 二十四 制作HTTP服务器端
- `HTTP服务器端就是Web服务器端`，定义是
    - 基于HTTP协议，将网页对应文件传输给客户端的服务器端
- `无状态的Stateless协议`：服务端不会维持客户端状态，即使同一客户端再次发送请求，服务端也无法辨认除原先那个，而会以相同方式处理新请求。使用`Cookie和Session技术`弥补这一缺点。
- http的`请求消息`的结构
    - `请求行`，请求行中含有请求方式(GET/POST等)，文件路径(/index.html),协议版本(HTTP/1.1)
    - `消息头`,其中包括发送请求(将要接受响应消息的)浏览器信息，用户认证信息等关于HTTP消息的附加信息，消息体中装有客户端向服务端传输的数据，为了装入数据，需要以POST方式发送请求。
    - `空行`
    - `消息体`，在GET请求中为空
- http的`响应消息`结构
    - `状态行`，`HTTP/1.1 200 OK`表示`我想用HTTP1.1版本进行响应，你的请求已正确处理（200 OK)`
    - `消息头`，其中含有传输数据类型和长度等信息。
    - `空行`
    - `消息体`,一般是html页面内容
- `char *strtok(char s[], const char *delim);`用于分割字符串，在第一次第调用之后，每次第一个参数应该传入`NULL`，这个函数会返回分割之后的小字符串，最后返回NULL。
- c语言编译器可以将多行字符串自动拼接，这些字符串之间用0个或者多个空白制表符以及换行符分开。
- 问题：Web服务器端与Web浏览器的说法错误？
# 参考
- [《TCP/IP网络编程》，作者尹圣雨](https://book.douban.com/subject/25911735/)