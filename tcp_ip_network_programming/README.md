# 一 理解网络编程和套接字
## 1.1 理解网络编程和套接字
- 网络编程中`接受`连接请求的套接字创建过程：
    - 调用socket函数创建套接字
    - 调用bind函数分配IP地址和端口号
    - 调用listen函数转为可接受请求状态
    - 调用accept函数受理连接请求
    - `如果启动了server，不能够立即重启服务端`
- `客户端`创建套接字的过程：
    - 调用socket函数和connect函数
    - 与服务端共同运行以收发字符串数据
## 1.2 基于Linux的文件操作
>在Linux中不区分`套接字`与`文件`，或则说套接字是一种文件
## 问题
- `套接字编程`与`网络编程`的联系
    - OS提供套接字(socket),套接字是网络传输的软件设备，所以`网络编程`就是`套接字编程`
- `底层文件IO(比如open)`与`ANSI标准的IO(比如fopen的区别)`
    - 文件I/O 又称为低级磁盘I/O，遵循POSIX相关标准。任何兼容POSIX标准的操作系统上都支持文件I/O。标准I/O被称为高级磁盘I/O，遵循ANSI C相关标准。只要开发环境中有标准I/O库，标准I/O就可以使用。（Linux 中使用的是GLIBC，它是标准C库的超集。不仅包含ANSI C中定义的函数，还包括POSIX标准中定义的函数。因此，Linux 下既可以使用标准I/O，也可以使用文件I/O）。
    - 通过文件I/O读写文件时，每次操作都会执行相关系统调用。这样处理的好处是直接读写实际文件，坏处是频繁的系统调用会增加系统开销，标准I/O可以看成是在文件I/O的基础上封装了缓冲机制。先读写缓冲区，必要时再访问实际文件，从而减少了系统调用的次数。
    - 文件I/O中用文件描述符表现一个打开的文件，可以访问不同类型的文件如普通文件、设备文件和管道文件等。而标准I/O中用FILE（流）表示一个打开的文件，通常只用来访问普通文件。
    - `底层IO`是系统调用，`文件IO`是函数，为了可移植性，因为库函数是对系统调用的封装，最好不要直接使用`系统调用`
# 二 套接字类型与协议设置
- TCP套接字和UDP套接字不会共用端口号，也即如果某TCP套接字使用9190端口，那么其他TCP套接字无法使用该端口号，但是UDP套接字可以使用
- 主流intel/AMD CPU是使用`小端序`，而网络传输数据采用`大端序`，大小端转换函数,其中`h`表示`host`，`n`表示`network`，`s`表示`short`(常用于端口转换)，`l`表示`long`（常用于IP地址转换，linx中long占4个字节)，**在本身就是大端的机器上，不会发生变化**：
    - unsigned short htons(unsigned short);
    - unsigned short ntohs(unsigned short);
    - unsigned long htons(unsigned long);
    - unsigned long ntohs(unsigned long);
- 除了向`sockaddr_in`填充数据之外，在传输数据的时候，不需要转换`大小端`。
- `in_addr_t inet_addr(const char * string)`用来将点分十进制转为`uint32_t`,并且会`检查错误`
- `int inet_aton(const char * string, struct in_addr * addr)`,也是将点分十进制转换为`uint32_t`，并且会将数据存储在`addr`中。
- `char *inet_ntoa(struct in_addr adr)`,此函数是将`uint32_t`转换为点分十进制，多次调用，需要将返回的char*的字符串拷贝，不然第二次调用会被覆盖。
- `addr.sin_addr.s_addr = htol(INADDR_ANY)`表示可以监听宿主机上的任意NIC的IP
# 四 基于TCP的服务器端/客户端(1)
- `网络编程的大部分内存就是设计并实现应用层协议`
- listen函数就是创建一个可以接受请求`服务端套接字`，该套接字相当于一个门，listen的第二个参数决定了`连接请求队列的大小`
- 由于`服务端套接字`需要当门卫，那么每次`accept`的时候需要创建`新的套接字`，用来与客户端连接
- 对于TCP的传输数据`没有边界性`，存在一些问题：
    - 多次write函数，可能会被client一次性接受
    - 也存在一次write函数的数据太长，数据需要分成两个数据包发送，那么client有可能在全部数据包未收全时，就是调用read
## 问题
- 什么时候创建连接请求等待队列？它有何种作用？与accept有什么关系？
    - 服务端调用listen函数后，accept函数正在处理客户端请求时，更多的客户端发来了请求连接的数据，此时，就需要创建连接请求等待队列。以便在accept函数处理完手头的请求之后，按照正确的顺序处理后面正在排队的其他请求。与accept函数的关系：accept函数受理连接请求等待队列中待处理的客户端连接请求。
- 客户端中为何不需要调用bind函数分配地址？如果不调用bind函数，那何时，如何向套接字分配IP地址和端口号？
    - 在调用connect函数时分配来地址，客户端IP地址和端口在调用connect函数时自动分配，无需调用标记bind函数进行分配。
# 五 基于TCP的服务器端/客户端(2)
- `应用层协议：`服务器端/客户端实现过程中逐步定义的这些规则集合就是应用层协议。
- `回声服务器的问题：`类似与`粘包/拆包`问题，client发送多少字节的数据，server就应该接受回送多少字节的数据。问题在于，***如果client要发送的包太大，server分成两次接受，那么有可能出现client在未收到全部数据包时，就调用read函数，会出现一个包的数据，分两行打印的情况**
- **习题等会写。。。**
# 六 基于UDP的服务端/客户端
- 在TCP中，若要向10个客户端提供服务，除了需要`守门`的套接字之外，还需要`10个服务器套接字`，但在UDP中，不管是客户端还是服务端，都只需要`一个套接字`。
- 在`TCP套接字`中，调用`connect`时OS会自动分配给套接字IP和端口号，无需调用bind函数分配;而在`UDP`中调用`sendto`函数时自动分配，而且这次分配会持续到程序结束为止。
- TCP数据传输不存在边界，也就是说`数据传输过程中IO函数的调用次数不具备任何意义`;UDP数据传输存在边界，`所以传输数据过程中调用IO函数的次数非常重要，也就是说输入函数调用的次数需要与输出函数的次数完全一致，因为是以数据包的方式传输`
- `UDP套接字`没有注册目标地址，那么可以重复利用同一套UDP套接字向不同目标传输数据，注册了目标地址的`套接字`叫做`connected`套接字，UDP的套机字会在调用一次sendto之后删除注册，那么
- UDP套接字`可以使用`已经分配给TCP的同一端口号。
- **7编程作业之后写**
# 七 优雅的断开套接字连接
- `只关闭一部分数据交换中使用的流`是指`传输数据但无法接受，或者接受数据但无法传输`，也就是关闭流的一半。
- `Linux的close函数`将把一个socket的输入/输出流都断开，那么需要`shutdown(int sock, int howto)函数`，第二个参数的可选值：
    - SHUT_RD 断开输入流
    - SHUT_WR 断开输出流
    - SHUT_RDWR 同时断开IO流
- 服务器在断开输出流的时候向客户端输出`EOF`
# 八 域名以及网络地址
- `nslookup`用来查看默认dns服务器地址，输入该命令之后，会提示输入`server`
- `DNS`可以看作是一个`分布式数据库系统`
- 不使用`IP`的原因，`IP`地址容易发生变化，且难以记忆
- 利用域名获取IP地址的函数`struct hostent *gethostname(const char *hostname);`
# 九 套接字的多种可选项
- 信号`CTRL+C`终止`server`，之后在去使用同一端口启动服务端，会出现`bind() error`,原因在于`time-wait`
- `time-wait`状态，在需要快速重启服务器的情况下，并不收欢迎，可以在套接字的可选项中更改`SO_REUSEADDR`的状态，其默认值为0,将其值设置为1,那么在`time-wait`状态下，就会被分配新的套接字端口
- `Nagle算法`：Nagle会最大限度的缓冲数据，在收到上一次发送的数据的ACK之前，不会去发送新的数据，而是尽量将数据缓存在缓冲区之中，这样可以减轻网络负载。但是传递`大文件数据`的时候，不适合使用`Nagle`算法，因为这个时候不需要等待ACK了，就可以连续发送。可以通过将套接字选项`TCP_NODELAY`修改为1,来禁用Nagle算法
# 十 多进程服务器端
- 实现`并发服务器端的实现模型与方法：`
    - 多进程服务器 
    - 多路复用服务器
    - 多线程服务器
- 对于子进程的`终止`，需要调用exit函数或者return函数，os不会去销毁子进程，直到exit的值或return返回的值被传递给父进程，但是需要父进程主动`发起请求`，os才会传递该值。换言之，如果os未主动要求获得子进程的结束状态值，os将一致保存，并让子进程长时间处于僵尸状态。
    - 利用`wait函数`，pid_t wait(int *statloc),如果调用该函数的时候，已经有子进程结束，那么子进程终止时传递的返回值将保存在该函数的参数所指的内存空间中。调用`wait`函数，如果没有已经终止的子进程，那么程序将阻塞直到有子进程终止。
    - `pid_t waitpid(pid_t pid, int *statloc, int options);`也可以回收僵尸进程，并且可以防止阻塞,第一个参数如果是-1,那么该函数和wait函数一样，可以等待任意子进程终止
    - 对于子进程的回收，父进程不能够只做这一件事，所以需要通过OS发送`信号`给`父进程`
        - 信号与singal函数，`void (*signal(int signo, void (*func)(int)))(int)`,参数是int signo， void（*func）(int),返回类型是参数为int型，返回为void型函数指针(这个返回值就是之前注册的函数指针)。这个函数用来`注册`信号函数
        - 调用函数的主体的确是OS，但是进程处于睡眠状态时无法调用函数，所以产生信号时(alarm到点，CTRL+C等)，`为了调用信号处理器，将唤醒由于调用sleep函数而进入阻塞状态的进程`，而且，进程一旦被唤醒，就不会再进入睡眠状态了，
    - 在父进程调用fork()之后，子进程只会复制文件描述符，对于`套接字`本身，不会发生复制，不然就同一端口对应多个套接字了
# 十一 进程间通信
- 为了实现进程间通信，OS需要为两个进程提供可以`同时访问的内存空间`
    - 通过`管道`实现进程间通信,fds[1]是管道入口，fds[0]是管道出口,`管道和套接字一样，属于OS,不是fork函数的赋值对象，但是fd的文件描述符是可以复制的`。一个进程在管道里写数据，也可以读出自己写的数据。父进程结束的时候，子进程可以仍然`在运行。`
    - 
# 参考
- [《TCP/IP网络编程》，作者尹圣雨](https://book.douban.com/subject/25911735/)